<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Pixel Canvas with WebGL</title>
    <style>
        body {
            text-align: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <h1>Random Pixel Canvas (WebGL)</h1>
    
    <label for="xResolution">X Resolution: </label>
    <input type="number" id="xResolution" value="100">
    <label for="yResolution">Y Resolution: </label>
    <input type="number" id="yResolution" value="100">
    <button onclick="generateCanvas()">Generate Canvas</button>
    <button onclick="saveCanvas()">Save Image</button>
    
    <br><br>
    <canvas id="canvas"></canvas>

    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_position;
        void main() {
            v_position = a_position;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec2 v_position;
        
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        void main() {
            float rand = random(v_position);
            if (rand < 0.5) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // 검은색
            } else {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); // 흰색
            }
        }
    </script>

    <script>
        function generateCanvas() {
            const x = parseInt(document.getElementById('xResolution').value);
            const y = parseInt(document.getElementById('yResolution').value);

            const canvas = document.getElementById('canvas');
            canvas.width = x;
            canvas.height = y;

            const gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WebGL is not supported by your browser.');
                return;
            }

            // 쉐이더 컴파일 함수
            function compileShader(gl, shaderSource, shaderType) {
                const shader = gl.createShader(shaderType);
                gl.shaderSource(shader, shaderSource);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile failed: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            // 버텍스 및 프래그먼트 쉐이더 로드
            const vertexShaderSource = document.getElementById('vertexShader').text;
            const fragmentShaderSource = document.getElementById('fragmentShader').text;
            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

            // 프로그램 생성 및 링크
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link failed: ' + gl.getProgramInfoLog(program));
                return;
            }
            gl.useProgram(program);

            // 위치 버퍼 설정
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = new Float32Array([
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0,
            ]);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // WebGL 그리기
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function saveCanvas() {
            const canvas = document.getElementById('canvas');
            const link = document.createElement('a');
            link.download = 'random_canvas_webgl.png';
            link.href = canvas.toDataURL();
            link.click();
        }
    </script>
</body>
</html>
