<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Pixel Canvas with WebGL</title>
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            text-align: center;
            font-family: Arial, sans-serif;
        }
        label {
            color: #ffffff;
        }
        canvas {
            border: 1px solid #ffffff;
        }
        button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 10px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Random Pixel Canvas (WebGL)</h1>
    
    <label for="xResolution">X Resolution: </label>
    <input type="number" id="xResolution" value="100">
    <label for="yResolution">Y Resolution: </label>
    <input type="number" id="yResolution" value="100">
    <button onclick="generateCanvas()">Generate Canvas</button>
    <button onclick="saveCanvas()">Save Image</button>
    
    <br><br>
    <canvas id="canvas"></canvas>

    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_position;
        void main() {
            v_position = a_position;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec2 v_position;
        
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        void main() {
            float rand = random(v_position);
            if (rand < 0.5) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // 검은색
            } else {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); // 흰색
            }
        }
    </script>

    <script>
        function generateCanvas() {
            const x = parseInt(document.getElementById('xResolution').value);
            const y = parseInt(document.getElementById('yResolution').value);

            const canvas = document.getElementById('canvas');
            canvas.width = x;
            canvas.height = y;

            const gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WebGL is not supported by your browser.');
                return;
            }

            // 쉐이더 컴파일 함수
            function compileShader(gl, shaderSource, shaderType) {
                const shader = gl.createShader(shaderType);
                gl.shaderSource(shader, shaderSource);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile failed: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            // 버텍스 및 프래그먼트 쉐이더 로드
            const vertexShaderSource = document.getElementById('vertexShader').text;
            const fragmentShaderSource = document.getElementById('fragmentShader').text;
            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER
